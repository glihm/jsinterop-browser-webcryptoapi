'use strict';

/**
 * Stores the keys generated by the Web Crypto API.
 */
var __keysRegistry = {};

/**
 * CryptoKeyDescriptor object that C# is sending to JS to interact with CryptoKey objects.
 * @typedef {Object} CryptoKeyDescriptor
 * @property {string} identifier - Unique identifier of the underlying key in the registry.
 * @property {string} type - Type of the key.
 * @property {boolean} extractable - Indicates whether or not the key may be extracted.
 */

/**
 * Deletes a key from the registry.
 * 
 * @param {CryptoKeyDescriptor} descriptor - Key descriptor.
 */
function deleteKey(descriptor) {
    if (descriptor.identifier in __keysRegistry) {
        delete __keysRegistry[descriptor.identifier];
    }
}

/**
 * Saves the given key and return it's descriptor.
 * 
 * @param {CryptoKey} key - Key to be saved.
 * @returns {CryptoKeyDescriptor} - Key descriptor.
 */
async function _saveKey(key) {
    const identifier = await self.crypto.randomUUID();

    const descriptor =
    {
        identifier: identifier,
        type: key.type,
        extractable: key.extractable,
    };

    __keysRegistry[descriptor.identifier] = key;
    return descriptor;
}

/**
 * Retrieves a key from the registry, or throw.
 * 
 * @param {CryptoKeyDescriptor} descriptor - Key descriptor.
 * @returns {CryptoKey} - Key associated with the descriptor.
 * @throws {Error} - No key associated with the provided descriptor.
 */
function _keyGetOrThrow(descriptor) {
    if (!descriptor.identifier in __keysRegistry) {
        throw new Error(`Key identifier ${descriptor.identifier} not found in the keys registry.`);
    }

    return __keysRegistry[descriptor.identifier];
}

/**
 * Generates a new key (symmetric algorithms) or key pair (pki algorithms).
 * Generated keys are stored in the registry.
 * 
 * Implements https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/generateKey.
 * 
 * @param {object} algorithm
 * @param {boolean} extractable
 * @param {Array<string>} keyUsages
 * @returns {Array<CryptoKeyDescriptor>} - Descriptors of generated keys, one if symmetric, two if pki.
 */
async function generateKey(algorithm, extractable, keyUsages) {

    let keyOrKeyPair = await self.crypto.subtle.generateKey(algorithm, extractable, keyUsages);

    if ("publicKey" in keyOrKeyPair) {
        const publicKey = await _saveKey(keyOrKeyPair.publicKey);
        const privateKey = await _saveKey(keyOrKeyPair.privateKey);
        return [publicKey, privateKey];
    } else {
        const key = await _saveKey(keyOrKeyPair);
        return [key];
    }
}

/**
 * Encrypts given data buffer.
 * Implements https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt.
 * 
 * @param {object} algorithm
 * @param {CryptoKeyDescriptor} descriptor
 * @param {Uint8Array} data - Data to be encrypted.
 * @returns {Uint8Array} - Ciphertext.
 */
async function encrypt(algorithm, descriptor, data) {
    const key = _keyGetOrThrow(descriptor);
    const ciphertext = await self.crypto.subtle.encrypt(algorithm, key, data);
    return new Uint8Array(ciphertext);
}

/**
 * Decrypts given data buffer.
 * Implements https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/decrypt.
 * 
 * @param {object} algorithm
 * @param {CryptoKeyDescriptor} descriptor
 * @param {Uint8Array} data - Data to be decrypted.
 * @returns {Uint8Array} - Plaintext.
 */
async function decrypt(algorithm, descriptor, data) {
    const key = _keyGetOrThrow(descriptor);
    const plaintext = await self.crypto.subtle.decrypt(algorithm, key, data);
    return new Uint8Array(plaintext);
}

/**
 * Generates a digital signature for the given data.
 * Implements https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/sign.
 * 
 * @param {object} algorithm
 * @param {CryptoKeyDescriptor} descriptor
 * @param {Uint8Array} data - Data to sign.
 * @returns {Uint8Array} - Signature.
 */
async function sign(algorithm, descriptor, data) {
    const key = _keyGetOrThrow(descriptor);
    const signature = await self.crypto.subtle.sign(algorithm, key, data);
    return new Uint8Array(signature);
}

/**
 * Verifies a digital signature on the given data.
 * Implements https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/verify.
 * 
 * @param {object} algorithm
 * @param {CryptoKeyDescriptor} descriptor
 * @param {Uint8Array} signature - Signature to verify.
 * @param {Uint8Array} data - Data on which the signature was generated.
 * @returns {boolean} - True if the signature is valid, false otherwise.
 */
async function verify(algorithm, descriptor, signature, data) {
    const key = _keyGetOrThrow(descriptor);
    return await self.crypto.subtle.verify(algorithm, key, signature, data);
}

/**
 * Exports a key to the given format.
 * Implements https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey.
 *
 * @param {string} format
 * @param {CryptoKeyDescriptor} descriptor
 * @returns {string|Uint8Array} - JSONWebKey if the format was 'jwk', a buffer otherwise.
 */
async function exportKey(format, descriptor) {
    const key = _keyGetOrThrow(descriptor);
    const exp = await self.crypto.subtle.exportKey(format, key);

    if (format === 'jwk') {
        return JSON.stringify(exp);
    } else {
        return new Uint8Array(exp);
    }
}

/**
 * Imports a key.
 * Implements https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey.
 *
 * @param {string} format
 * @param {object|Uint8Array} keyData
 * @param {object} algorithm
 * @param {boolean} extractable
 * @param {Array<string>} keyUsages
 * @returns {CryptoKeyDescriptor} - Descriptor of the imported key.
 */
async function importKey(format, keyData, algorithm, extractable, keyUsages) {
    const key = await self.crypto.subtle.importKey(format, keyData, algorithm, extractable, keyUsages);
    return await _saveKey(key);
}

/**
 * Derives secret key from a master key.
 * Implements https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey.
 *
 * @param {object} algorithm
 * @param {CryptoKeyDescriptor} descriptor
 * @param {object} derivedKeyAlgorithm
 * @param {boolean} extractable
 * @param {Array<string>} keyUsages
 * @returns {CryptoKeyDescriptor} - Descriptor of the derived key.
 */
async function deriveKey(algorithm, descriptor, derivedKeyAlgorithm, extractable, keyUsages) {
    // ECDH requires a JS crypto key to operate. This key must be extract from algorithm object.
    if (algorithm.name == 'ECDH') {
        // replace the public property with the actual JS crypto key.
        algorithm.public = _keyGetOrThrow(algorithm.public);
    }

    const baseKey = _keyGetOrThrow(descriptor);
    const key = await self.crypto.subtle.deriveKey(algorithm, baseKey, derivedKeyAlgorithm, extractable, keyUsages);
    return await _saveKey(key);
}

/**
 * Derives array of bits from a master key.
 * Implements https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveBits.
 *
 * @param {object} algorithm
 * @param {CryptoKeyDescriptor} descriptor
 * @param {number} length
 * @returns {Uint8Array} - Buffer with derived bits.
 */
async function deriveBits(algorithm, descriptor, length) {

    // ECDH requires a JS crypto key to operate. This key must be extract from algorithm object.
    if (algorithm.name == 'ECDH') {
        // replace the public property with the actual JS crypto key.
        algorithm.public = _keyGetOrThrow(algorithm.public);
    }

    const baseKey = _keyGetOrThrow(descriptor);
    const dbits = await self.crypto.subtle.deriveBits(algorithm, baseKey, length);
    return new Uint8Array(dbits);
}

/**
 * Wraps a key.
 * Implements https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/wrapKey.
 *
 * @param {string} format
 * @param {CryptoKeyDescriptor} descriptor
 * @param {CryptoKeyDescriptor} wrapDescriptor
 * @param {object} wrapAlgo
 * @returns {Uint8Array} - Buffer with the encrypted key.
 */
async function wrapKey(format, descriptor, wrapDescriptor, wrapAlgo) {
    const key = _keyGetOrThrow(descriptor);
    const wrappingKey = _keyGetOrThrow(wrapDescriptor);
    const buf = await self.crypto.subtle.wrapKey(format, key, wrappingKey, wrapAlgo);
    return new Uint8Array(buf);
}

/**
 * Unwraps a key.
 * Implements https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/unwrapKey.
 *
 * @param {string} format
 * @param {Uint8Array} wrappedKey
 * @param {CryptoKeyDescriptor} unwrapDescriptor
 * @param {object} unwrapAlgo
 * @param {object} unwrappedKeyAlgo
 * @param {boolean} extractable
 * @param {Array<string>} keyUsages
 * @returns {CryptoKeyDescriptor} - Unwrap key's descriptor.
 */
async function unwrapKey(format, wrappedKey, unwrappingDescriptor, unwrapAlgo, unwrappedKeyAlgo, extractable, keyUsages) {
    const unwrappingKey = _keyGetOrThrow(unwrappingDescriptor);
    const key = await self.crypto.subtle.unwrapKey(format, wrappedKey, unwrappingKey, unwrapAlgo, unwrappedKeyAlgo, extractable, keyUsages);
    return await _saveKey(key);
}

/**
 * Generates a digest of the given data.
 * Implements https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest.
 * 
 * @param {object} algorithm
 * @param {Uint8Array} data
 * @returns {Uint8Array} - Digest of the data.
 */
async function digest(algorithm, data) {
    const d = await self.crypto.subtle.digest(algorithm, data);
    return new Uint8Array(d);
}

/**
 * Dumps keys, debug only.
 */
function dumpKeys() {
    console.log(__keysRegistry);
}


export {
    dumpKeys,

    deleteKey,
    generateKey,
    importKey,
    exportKey,

    encrypt,
    decrypt,
    sign,
    verify,
    digest,
    deriveKey,
    deriveBits,

    wrapKey,
    unwrapKey,

}
